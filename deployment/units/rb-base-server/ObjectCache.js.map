{"version":3,"sources":["../../../units/rb-base-server/ObjectCache.js"],"names":["expirationCheckInterval","expirationIntervalTimer","MapCachesByCategory","Map","executeDiscard","cacheKey","discardFunction","objectPromise","err","message","NestedError","cleanupCategory","cachedEntriesForCategory","definition","entries","size","countMax","arrCreatedTime","cachedEntry","values","push","createdTimeMs","sort","a","b","cutOffTimeMs","onDiscard","delete","removeExpired","debugWriteToConsoleObjectCacheActivity","logEntries","bPerishableItemsLeft","timeMsNow","Date","getTime","expirationDurationMs","expiresAtMs","clearInterval","getCachedEntryFromCache","categoryName","get","Error","validByTimeMs","isValid","validityVerificationPromise","validityVerifier","Promise","resolve","validityDurationMs","title","display","name","key","validBy","validByLeft","expires","expiresLeft","console","log","table","ObjectCache","getOrCreateObjectFromCahce_async","creationFunction","currentCachedEntry","newObjectPromise","addObjectToCache_async","creationPromise","setInterval","set","initializeObjectCache","CacheableCategoryDefinitions","getObjectFromCache_async"],"mappings":"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","sourcesContent":["// @flow\n\nimport NestedError from 'nested-error-stacks'\n\nimport CacheableCategoryDefinitions from '../_configuration/rb-base-server/CacheableCategoryDefinitions'\nimport { debugWriteToConsoleObjectCacheActivity } from '../_configuration/debug'\n\nimport log from './log'\nimport type { CachedEntriesForCategory, CachedEntry } from './types/ObjectCache.types'\n\n//\n\nconst expirationCheckInterval = 5000\nlet expirationIntervalTimer = null\n\nconst MapCachesByCategory: Map<string, CachedEntriesForCategory> = new Map()\n\n//\n\nasync function executeDiscard(\n  cacheKey: string,\n  discardFunction: Function,\n  objectPromise: Promise<Object>,\n) {\n  try {\n    await discardFunction(objectPromise)\n  } catch (err) {\n    const message = 'rb-base-server ObjectCache executeDiscard: failed'\n    log('error', message, { cacheKey, err })\n    throw new NestedError(message, err)\n  }\n}\n\nasync function cleanupCategory(cachedEntriesForCategory: CachedEntriesForCategory) {\n  const { definition, entries } = cachedEntriesForCategory\n\n  // If the number if cached elements does not exceed max, no cleanup is necessary\n  if (entries.size <= definition.countMax) return\n\n  // Collect all the tics times\n  const arrCreatedTime: Array<number> = []\n  for (let cachedEntry of entries.values()) {\n    arrCreatedTime.push(cachedEntry.createdTimeMs)\n  }\n\n  // Descending sort - newest entries come first\n  arrCreatedTime.sort((a, b) => b - a)\n\n  // Remove all entries that are older than cutoff time\n  const cutOffTimeMs = arrCreatedTime[definition.countMax - 1]\n  for (let [ cacheKey, cachedEntry ] of entries.entries()) {\n    if (cachedEntry.createdTimeMs < cutOffTimeMs) {\n      // Discard if necessary. Do not wait.\n      const discardFunction = definition.onDiscard\n      if (discardFunction) {\n        const objectPromise = cachedEntry.objectPromise\n        executeDiscard(cacheKey, discardFunction, await objectPromise)\n      }\n\n      // Remove from map of cached objects\n      entries.delete(cacheKey)\n    }\n  }\n}\n\nasync function removeExpired() {\n  if (debugWriteToConsoleObjectCacheActivity) logEntries('removeExpired - before')\n\n  let bPerishableItemsLeft = false\n\n  const timeMsNow = new Date().getTime()\n\n  for (let cachedEntriesForCategory of MapCachesByCategory.values()) {\n    const { definition, entries } = cachedEntriesForCategory\n\n    // If there is no expiration for the category, skip\n    if (!definition.expirationDurationMs) continue\n\n    const discardFunction = definition.onDiscard\n\n    // Delete expired entries\n    for (let [ cacheKey, cachedEntry ] of entries.entries()) {\n      // $FlowIgnore expiresAtMs will be present\n      if (cachedEntry.expiresAtMs < timeMsNow) {\n        // Discard if necessary. Do not wait.\n        if (discardFunction) {\n          const objectPromise = cachedEntry.objectPromise\n          executeDiscard(cacheKey, discardFunction, await objectPromise)\n        }\n\n        // Remove from map of cached objects\n        entries.delete(cacheKey)\n      } else bPerishableItemsLeft = true\n    }\n  }\n\n  // If there are no more perishable items, simply remove the timer\n  if (!bPerishableItemsLeft) {\n    clearInterval(expirationIntervalTimer)\n    expirationIntervalTimer = null\n  }\n\n  if (debugWriteToConsoleObjectCacheActivity) logEntries('removeExpired - after')\n}\n\nasync function getCachedEntryFromCache(\n  categoryName: string,\n  cacheKey: string,\n): Promise<?CachedEntry> {\n  const cachedEntriesForCategory = MapCachesByCategory.get(categoryName)\n  if (cachedEntriesForCategory == null)\n    throw new Error('getCachedEntryFromCache: can not find cacheable category ' + categoryName)\n\n  const { definition, entries } = cachedEntriesForCategory\n  const cachedEntry = entries.get(cacheKey)\n\n  // Entry is not present in cache ?\n  if (cachedEntry == null) return null\n\n  const timeMsNow = new Date().getTime()\n\n  // Entry is in the cache\n  // If the entry already has expiration, increase it since it is used\n  if (cachedEntry.expiresAtMs) {\n    const cachedEntriesForCategory = MapCachesByCategory.get(categoryName)\n\n    // $FlowIgnore our code is written in a way that definition would be present\n    const { definition } = cachedEntriesForCategory\n\n    cachedEntry.expiresAtMs = timeMsNow + definition.expirationDurationMs\n  }\n\n  if (cachedEntry.validByTimeMs >= timeMsNow) {\n    return cachedEntry\n  }\n\n  // Run the function to verify the validity of the cached entry, or wait for\n  // a validity verification function that's already running\n  let isValid: boolean = false\n  if (cachedEntry.validityVerificationPromise == null) {\n    try {\n      cachedEntry.validityVerificationPromise = definition.validityVerifier(cacheKey, cachedEntry)\n      isValid = await cachedEntry.validityVerificationPromise\n    } catch (err) {\n      // Indicate that the entry is invalid\n      cachedEntry.validityVerificationPromise = Promise.resolve(false)\n\n      // Record the problem and throw exception further\n      const message =\n        'rb-base-server ObjectCache getCachedEntryFromCache: validityVerificationPromise failed'\n      log('error', message, { categoryName, cacheKey, err })\n      throw new NestedError(message, err)\n    }\n  }\n\n  cachedEntry.validityVerificationPromise = null\n  if (isValid) {\n    cachedEntry.validByTimeMs = timeMsNow + definition.validityDurationMs\n    return cachedEntry\n  } else {\n    // Entry is present in cache, but is invalid. Delete\n    entries.delete(cacheKey)\n    return new Promise(() => null)\n  }\n}\n\nfunction logEntries(title: string) {\n  const timeMsNow = new Date().getTime()\n  const values: Array<Object> = []\n\n  for (let cachedEntriesForCategory of MapCachesByCategory.values()) {\n    const { definition, entries } = cachedEntriesForCategory\n\n    // Delete expired entries\n    for (let [ cacheKey, cachedEntry ] of entries.entries()) {\n      const display = {\n        name: definition.name,\n        key: cacheKey,\n        validBy: cachedEntry.validByTimeMs,\n        validByLeft: cachedEntry.validByTimeMs - timeMsNow,\n        expires: 0,\n        expiresLeft: 0,\n      }\n\n      if (cachedEntry.expiresAtMs) {\n        display.expires = cachedEntry.expiresAtMs\n        display.expiresLeft = cachedEntry.expiresAtMs - timeMsNow\n      }\n\n      values.push(display)\n    }\n  }\n\n  console.log('XXX ' + title + ' @ ' + timeMsNow)\n  console.table(values)\n}\n\n/**\n * Class encapsulating static members for managing object cahce\n */\nexport default class ObjectCache {\n  /** Retrieve existing cached object or create a new one, given category and key */\n  static async getOrCreateObjectFromCahce_async(\n    categoryName: string,\n    cacheKey: string,\n    creationFunction: Function,\n  ): Object {\n    const currentCachedEntry = await getCachedEntryFromCache(categoryName, cacheKey)\n\n    // If it is already present in cache, return\n    if (currentCachedEntry) {\n      return await currentCachedEntry.objectPromise\n    }\n\n    // Not present in cache - create\n    let newObjectPromise\n    try {\n      newObjectPromise = creationFunction()\n    } catch (err) {\n      const message =\n        'rb-base-server ObjectCache getOrCreateObjectFromCahce: creationFunction failed'\n      log('error', message, { cacheKey, err })\n      throw new NestedError(message, err)\n    }\n\n    // Add the promise to the cache now, so that other requests to the cache\n    // for the same entry use the promise and do not kick off a second\n    // creation function\n    ObjectCache.addObjectToCache_async(categoryName, cacheKey, newObjectPromise)\n\n    if (debugWriteToConsoleObjectCacheActivity) logEntries('getOrCreateObjectFromCahce')\n\n    try {\n      return await newObjectPromise\n    } catch (err) {\n      const message =\n        'rb-base-server ObjectCache getOrCreateObjectFromCahce: await creationFunction failed'\n      log('error', message, { categoryName, cacheKey, err })\n\n      const cachedEntriesForCategory = MapCachesByCategory.get(categoryName)\n\n      // $FlowIgnore it is guaranteed that the category exists\n      const { entries } = cachedEntriesForCategory\n      entries.delete(cacheKey)\n\n      throw new NestedError(message, err)\n    }\n  }\n\n  /** Adds an object to cache by category and cache key. */\n  static async addObjectToCache_async(\n    categoryName: string,\n    cacheKey: string,\n    objectPromise: Promise<Object>,\n  ) {\n    const cachedEntriesForCategory = MapCachesByCategory.get(categoryName)\n    if (cachedEntriesForCategory == null)\n      throw new Error('addObjectToCache: can not find cacheable category ' + categoryName)\n\n    const { definition, entries } = cachedEntriesForCategory\n\n    const timeMsNow = new Date().getTime()\n\n    const cachedEntry: CachedEntry = {\n      createdTimeMs: timeMsNow,\n      validByTimeMs: timeMsNow + definition.validityDurationMs,\n      objectPromise,\n      validityVerificationPromise: null,\n      creationPromise: null,\n    }\n\n    if (definition.expirationDurationMs) {\n      // Only start timer when first object with expiration is added. No reason to run it before\n      // that.\n      if (expirationIntervalTimer == null) {\n        expirationIntervalTimer = setInterval(removeExpired, expirationCheckInterval)\n      }\n\n      cachedEntry.expiresAtMs = timeMsNow + definition.expirationDurationMs\n    }\n\n    entries.set(cacheKey, cachedEntry)\n\n    await cleanupCategory(cachedEntriesForCategory)\n\n    if (debugWriteToConsoleObjectCacheActivity) logEntries('addObjectToCache key=' + cacheKey)\n  }\n\n  static initializeObjectCache() {\n    for (let definition of CacheableCategoryDefinitions) {\n      MapCachesByCategory.set(definition.name, {\n        definition,\n        entries: new Map(),\n      })\n    }\n  }\n\n  static async getObjectFromCache_async(categoryName: string, cacheKey: string): ?Object {\n    const cachedEntry = await getCachedEntryFromCache(categoryName, cacheKey)\n\n    if (cachedEntry) {\n      return await cachedEntry.objectPromise\n    } else {\n      return null\n    }\n  }\n}\n"],"file":"ObjectCache.js"}